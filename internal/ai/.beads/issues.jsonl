{"id":"vc-225","title":"Add input validation to DiagnoseTestFailure()","description":"The DiagnoseTestFailure() function in internal/ai/test_failure.go doesn't validate inputs, which could lead to panics.\n\nCurrent code:\nfunc (s *Supervisor) DiagnoseTestFailure(ctx context.Context, issue *types.Issue, testOutput string) (*TestFailureDiagnosis, error) {\n    // No checks for nil issue or empty testOutput\n    startTime := time.Now()\n    ...\n\nRisk: Nil pointer dereference if issue is nil, or wasted AI API call if testOutput is empty.\n\nFound during vc-210 code review.","design":"Add validation at the start of DiagnoseTestFailure():\n\nif issue == nil {\n    return nil, fmt.Errorf(\"issue cannot be nil\")\n}\nif testOutput == \"\" {\n    return nil, fmt.Errorf(\"test output cannot be empty\")\n}\n\nAlso consider adding length check to avoid sending massive outputs to AI:\nif len(testOutput) \u003e 100000 {\n    testOutput = testOutput[:100000] + \"\\n... (truncated)\"\n}","acceptance_criteria":"- DiagnoseTestFailure validates issue is not nil\n- DiagnoseTestFailure validates testOutput is not empty\n- Unit test for nil issue input\n- Unit test for empty testOutput\n- Optional: Truncate very large test outputs","notes":"Starting work - adding input validation to DiagnoseTestFailure()","status":"closed","priority":3,"issue_type":"task","created_at":"2025-10-28T17:15:57.286928-07:00","updated_at":"2025-10-28T18:03:15.263935-07:00","closed_at":"2025-10-28T18:03:15.263935-07:00"}
{"id":"vc-226","title":"Improve baseline issue detection in prompt template","description":"The baseline issue detection in internal/executor/prompt.go uses a simple string prefix check:\n\nisBaselineIssue := len(ctx.Issue.ID) \u003e= 12 \u0026\u0026 ctx.Issue.ID[:12] == \"vc-baseline-\"\n\nProblems:\n- Hardcoded magic number (12)\n- No validation of gate type\n- Could match unintended IDs like 'vc-baseline-foobar-whatever'\n\nFound during vc-210 code review.","design":"Use an explicit allowlist of valid baseline issue IDs:\n\nvar validBaselineIssues = map[string]bool{\n    \"vc-baseline-test\": true,\n    \"vc-baseline-lint\": true,\n    \"vc-baseline-build\": true,\n}\nisBaselineIssue := validBaselineIssues[ctx.Issue.ID]\n\nAlternatively, use a regex:\nisBaselineIssue := regexp.MustCompile(`^vc-baseline-(test|lint|build)$`).MatchString(ctx.Issue.ID)\n\nThe allowlist approach is faster (O(1) map lookup vs regex).","acceptance_criteria":"- Baseline detection uses explicit allowlist or validated regex\n- No magic numbers in code\n- Only valid gate types (test, lint, build) are matched\n- Add test for invalid baseline ID (e.g., vc-baseline-invalid)\n- Add test for edge case IDs (e.g., vc-baseline without suffix)","notes":"Starting work - improving baseline issue detection in prompt template","status":"closed","priority":3,"issue_type":"task","created_at":"2025-10-28T17:16:14.465351-07:00","updated_at":"2025-10-28T18:04:17.187674-07:00","closed_at":"2025-10-28T18:04:17.187674-07:00"}
{"id":"vc-227","title":"Truncate AI responses in error messages to prevent log spam","description":"Several AI supervisor functions include full AI responses in error messages, which can spam logs with 4096+ tokens of text.\n\nExample from internal/ai/test_failure.go:\nreturn nil, fmt.Errorf(\"failed to parse test failure diagnosis: %s (response: %s)\", parseResult.Error, responseText)\n\nWhen responseText is 4096 tokens, this makes logs unreadable.\n\nFound during vc-210 code review.","design":"Replace error messages that include full AI responses with truncated versions:\n\nBefore:\nfmt.Errorf(\"failed to parse: %s (response: %s)\", parseResult.Error, responseText)\n\nAfter:\nfmt.Errorf(\"failed to parse: %s\", parseResult.Error)\n\nOr with truncation:\ntruncated := responseText\nif len(responseText) \u003e 200 {\n    truncated = responseText[:200] + \"... (truncated)\"\n}\nfmt.Errorf(\"failed to parse: %s (response: %s)\", parseResult.Error, truncated)\n\nCheck all AI supervisor functions:\n- DiagnoseTestFailure() in test_failure.go\n- AnalyzeExecutionResult() in analysis.go  \n- AssessIssueState() in assessment.go\n- Any other functions that parse AI responses","acceptance_criteria":"- Error messages don't include full AI responses\n- AI response errors either omit response or truncate to ~200 chars\n- Logs remain readable even when AI parsing fails\n- Check all supervisor functions for this pattern","notes":"Starting work - truncating AI responses in error messages","status":"closed","priority":3,"issue_type":"task","created_at":"2025-10-28T17:18:03.032023-07:00","updated_at":"2025-10-28T18:07:19.55608-07:00","closed_at":"2025-10-28T18:07:19.55608-07:00"}
{"id":"vc-228","title":"Fix FailureType inconsistency between events and AI code","description":"There's a type inconsistency between event data structures and AI code:\n\nIn internal/events/types.go (TestFailureDiagnosisData):\nFailureType string `json:\"failure_type\"` // plain string\n\nIn internal/ai/test_failure.go:\ntype FailureType string\nconst (\n    FailureTypeFlaky FailureType = \"flaky\"\n    FailureTypeReal FailureType = \"real\"\n    ...\n)\n\nRisk: When emitting events, developers might typo the failure type string, leading to inconsistent data.\n\nFound during vc-210 code review.","design":"Two approaches:\n\n1. Use FailureType enum everywhere:\n   - Export FailureType from ai package\n   - Use ai.FailureType in event data structures\n   - Ensures compile-time type safety\n\n2. Add validation function:\n   - Keep events as strings (more flexible for JSON)\n   - Add IsValidFailureType(ft string) bool helper\n   - Document valid values in comments\n\nRecommendation: Use approach #1 (enum everywhere) for type safety.","acceptance_criteria":"- Event data structures use typed FailureType instead of string\n- OR: Add validation function and document valid values\n- Update any code that emits these events to use enum\n- Add test verifying type consistency","notes":"Starting work - fixing FailureType inconsistency between events and AI code","status":"closed","priority":3,"issue_type":"task","created_at":"2025-10-28T17:18:21.013884-07:00","updated_at":"2025-10-28T18:09:37.841989-07:00","closed_at":"2025-10-28T18:09:37.841989-07:00"}
{"id":"vc-229","title":"Add edge case tests for baseline issue detection","description":"The baseline issue tests in internal/executor/prompt_test.go only test happy paths:\n- vc-baseline-test (valid)\n- vc-baseline-lint (valid)\n- vc-210 (not baseline)\n\nMissing edge cases:\n- 'vc-baseline' (exactly 11 chars, fails length check)\n- 'vc-baseline-invalid' (unknown gate type)\n- 'vc-baseline-' (empty gate type)\n- Empty issue ID\n- Very long issue ID\n\nFound during vc-210 code review.","design":"Add test cases:\n\nfunc TestBuildPrompt_BaselineEdgeCases(t *testing.T) {\n    tests := []struct {\n        name           string\n        issueID        string\n        shouldBaseline bool\n    }{\n        {\"exactly 11 chars\", \"vc-baseline\", false},\n        {\"invalid gate\", \"vc-baseline-invalid\", false},\n        {\"empty gate\", \"vc-baseline-\", false},\n        {\"empty ID\", \"\", false},\n        {\"valid test gate\", \"vc-baseline-test\", true},\n    }\n    \n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            // Test that baseline section appears/doesn't appear\n        })\n    }\n}\n\nAlso add tests verifying content quality, not just string containment.","acceptance_criteria":"- Test for 'vc-baseline' (too short)\n- Test for invalid gate types\n- Test for empty gate type  \n- Test for empty issue ID\n- All edge cases handled correctly\n- Tests verify prompt content, not just string presence","notes":"Starting work - adding edge case tests for baseline issue detection","status":"closed","priority":3,"issue_type":"task","created_at":"2025-10-28T17:18:40.408612-07:00","updated_at":"2025-10-28T18:10:32.969644-07:00","closed_at":"2025-10-28T18:10:32.969644-07:00"}
