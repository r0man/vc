{"id":"vc-225","title":"Add input validation to DiagnoseTestFailure()","description":"The DiagnoseTestFailure() function in internal/ai/test_failure.go doesn't validate inputs, which could lead to panics.\n\nCurrent code:\nfunc (s *Supervisor) DiagnoseTestFailure(ctx context.Context, issue *types.Issue, testOutput string) (*TestFailureDiagnosis, error) {\n    // No checks for nil issue or empty testOutput\n    startTime := time.Now()\n    ...\n\nRisk: Nil pointer dereference if issue is nil, or wasted AI API call if testOutput is empty.\n\nFound during vc-210 code review.","design":"Add validation at the start of DiagnoseTestFailure():\n\nif issue == nil {\n    return nil, fmt.Errorf(\"issue cannot be nil\")\n}\nif testOutput == \"\" {\n    return nil, fmt.Errorf(\"test output cannot be empty\")\n}\n\nAlso consider adding length check to avoid sending massive outputs to AI:\nif len(testOutput) \u003e 100000 {\n    testOutput = testOutput[:100000] + \"\\n... (truncated)\"\n}","acceptance_criteria":"- DiagnoseTestFailure validates issue is not nil\n- DiagnoseTestFailure validates testOutput is not empty\n- Unit test for nil issue input\n- Unit test for empty testOutput\n- Optional: Truncate very large test outputs","status":"open","priority":3,"issue_type":"task","created_at":"2025-10-28T17:15:57.286928-07:00","updated_at":"2025-10-28T17:15:57.286928-07:00"}
{"id":"vc-226","title":"Improve baseline issue detection in prompt template","description":"The baseline issue detection in internal/executor/prompt.go uses a simple string prefix check:\n\nisBaselineIssue := len(ctx.Issue.ID) \u003e= 12 \u0026\u0026 ctx.Issue.ID[:12] == \"vc-baseline-\"\n\nProblems:\n- Hardcoded magic number (12)\n- No validation of gate type\n- Could match unintended IDs like 'vc-baseline-foobar-whatever'\n\nFound during vc-210 code review.","design":"Use an explicit allowlist of valid baseline issue IDs:\n\nvar validBaselineIssues = map[string]bool{\n    \"vc-baseline-test\": true,\n    \"vc-baseline-lint\": true,\n    \"vc-baseline-build\": true,\n}\nisBaselineIssue := validBaselineIssues[ctx.Issue.ID]\n\nAlternatively, use a regex:\nisBaselineIssue := regexp.MustCompile(`^vc-baseline-(test|lint|build)$`).MatchString(ctx.Issue.ID)\n\nThe allowlist approach is faster (O(1) map lookup vs regex).","acceptance_criteria":"- Baseline detection uses explicit allowlist or validated regex\n- No magic numbers in code\n- Only valid gate types (test, lint, build) are matched\n- Add test for invalid baseline ID (e.g., vc-baseline-invalid)\n- Add test for edge case IDs (e.g., vc-baseline without suffix)","status":"open","priority":3,"issue_type":"task","created_at":"2025-10-28T17:16:14.465351-07:00","updated_at":"2025-10-28T17:16:14.465351-07:00"}
{"id":"vc-227","title":"Truncate AI responses in error messages to prevent log spam","description":"Several AI supervisor functions include full AI responses in error messages, which can spam logs with 4096+ tokens of text.\n\nExample from internal/ai/test_failure.go:\nreturn nil, fmt.Errorf(\"failed to parse test failure diagnosis: %s (response: %s)\", parseResult.Error, responseText)\n\nWhen responseText is 4096 tokens, this makes logs unreadable.\n\nFound during vc-210 code review.","design":"Replace error messages that include full AI responses with truncated versions:\n\nBefore:\nfmt.Errorf(\"failed to parse: %s (response: %s)\", parseResult.Error, responseText)\n\nAfter:\nfmt.Errorf(\"failed to parse: %s\", parseResult.Error)\n\nOr with truncation:\ntruncated := responseText\nif len(responseText) \u003e 200 {\n    truncated = responseText[:200] + \"... (truncated)\"\n}\nfmt.Errorf(\"failed to parse: %s (response: %s)\", parseResult.Error, truncated)\n\nCheck all AI supervisor functions:\n- DiagnoseTestFailure() in test_failure.go\n- AnalyzeExecutionResult() in analysis.go  \n- AssessIssueState() in assessment.go\n- Any other functions that parse AI responses","acceptance_criteria":"- Error messages don't include full AI responses\n- AI response errors either omit response or truncate to ~200 chars\n- Logs remain readable even when AI parsing fails\n- Check all supervisor functions for this pattern","status":"open","priority":3,"issue_type":"task","created_at":"2025-10-28T17:18:03.032023-07:00","updated_at":"2025-10-28T17:18:03.032023-07:00"}
{"id":"vc-228","title":"Fix FailureType inconsistency between events and AI code","description":"There's a type inconsistency between event data structures and AI code:\n\nIn internal/events/types.go (TestFailureDiagnosisData):\nFailureType string `json:\"failure_type\"` // plain string\n\nIn internal/ai/test_failure.go:\ntype FailureType string\nconst (\n    FailureTypeFlaky FailureType = \"flaky\"\n    FailureTypeReal FailureType = \"real\"\n    ...\n)\n\nRisk: When emitting events, developers might typo the failure type string, leading to inconsistent data.\n\nFound during vc-210 code review.","design":"Two approaches:\n\n1. Use FailureType enum everywhere:\n   - Export FailureType from ai package\n   - Use ai.FailureType in event data structures\n   - Ensures compile-time type safety\n\n2. Add validation function:\n   - Keep events as strings (more flexible for JSON)\n   - Add IsValidFailureType(ft string) bool helper\n   - Document valid values in comments\n\nRecommendation: Use approach #1 (enum everywhere) for type safety.","acceptance_criteria":"- Event data structures use typed FailureType instead of string\n- OR: Add validation function and document valid values\n- Update any code that emits these events to use enum\n- Add test verifying type consistency","status":"open","priority":3,"issue_type":"task","created_at":"2025-10-28T17:18:21.013884-07:00","updated_at":"2025-10-28T17:18:21.013884-07:00"}
{"id":"vc-229","title":"Add edge case tests for baseline issue detection","description":"The baseline issue tests in internal/executor/prompt_test.go only test happy paths:\n- vc-baseline-test (valid)\n- vc-baseline-lint (valid)\n- vc-210 (not baseline)\n\nMissing edge cases:\n- 'vc-baseline' (exactly 11 chars, fails length check)\n- 'vc-baseline-invalid' (unknown gate type)\n- 'vc-baseline-' (empty gate type)\n- Empty issue ID\n- Very long issue ID\n\nFound during vc-210 code review.","design":"Add test cases:\n\nfunc TestBuildPrompt_BaselineEdgeCases(t *testing.T) {\n    tests := []struct {\n        name           string\n        issueID        string\n        shouldBaseline bool\n    }{\n        {\"exactly 11 chars\", \"vc-baseline\", false},\n        {\"invalid gate\", \"vc-baseline-invalid\", false},\n        {\"empty gate\", \"vc-baseline-\", false},\n        {\"empty ID\", \"\", false},\n        {\"valid test gate\", \"vc-baseline-test\", true},\n    }\n    \n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            // Test that baseline section appears/doesn't appear\n        })\n    }\n}\n\nAlso add tests verifying content quality, not just string containment.","acceptance_criteria":"- Test for 'vc-baseline' (too short)\n- Test for invalid gate types\n- Test for empty gate type  \n- Test for empty issue ID\n- All edge cases handled correctly\n- Tests verify prompt content, not just string presence","status":"open","priority":3,"issue_type":"task","created_at":"2025-10-28T17:18:40.408612-07:00","updated_at":"2025-10-28T17:18:40.408612-07:00"}
{"id":"vc-230","title":"Integrate DiagnoseTestFailure into executor flow","description":"The DiagnoseTestFailure() function in internal/ai/test_failure.go is implemented but not yet called anywhere. This is foundation work from vc-210.\n\nCurrent state:\n- âœ“ AI diagnosis function exists\n- âœ“ Baseline prompt template exists\n- âœ“ Event types defined\n- âœ— Not wired into executor\n- âœ— No events emitted\n- âœ— No end-to-end test\n\nThe self-healing foundation is complete but not integrated.\n\nFound during vc-210 code review.","design":"Integration points:\n\n1. Call DiagnoseTestFailure when baseline issue is claimed:\n   - In executeIssue(), detect baseline issues\n   - Before spawning agent, call supervisor.DiagnoseTestFailure()\n   - Pass diagnosis to agent as additional context (optional)\n   - Emit baseline_test_fix_started event\n\n2. Track completion:\n   - In results processor, detect baseline issue completion\n   - Emit baseline_test_fix_completed event with metrics\n   - Include: success, fix_type, tests_fixed, commit_hash\n\n3. Add end-to-end test:\n   - Create failing test â†’ preflight creates baseline issue\n   - Executor claims baseline issue\n   - Agent receives specialized prompt\n   - Agent fixes test\n   - Tests pass, baseline issue closed\n\nThis enables the full self-healing loop.","acceptance_criteria":"- DiagnoseTestFailure called when baseline issue claimed\n- baseline_test_fix_started event emitted with test names\n- baseline_test_fix_completed event emitted with metrics\n- End-to-end test of full self-healing flow\n- Metrics can be queried from agent_events table\n- Documentation updated with self-healing workflow","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-28T17:19:01.266689-07:00","updated_at":"2025-10-28T17:19:01.266689-07:00"}
{"id":"vc-231","title":"Update CLAUDE.md with self-healing documentation","description":"CLAUDE.md doesn't mention the new self-healing capability added in vc-210. Users working with the codebase won't know this feature exists or how it works.\n\nNew capabilities to document:\n- Baseline test failure self-healing\n- AI-powered test failure diagnosis (flaky/real/environmental)\n- Specialized prompts for baseline issues\n- Event tracking for self-healing metrics\n\nFound during vc-210 code review.","design":"Add new section to CLAUDE.md after the Preflight section:\n\n## ðŸ”§ Self-Healing Baseline Failures (vc-210)\n\nWhen preflight detects baseline test failures, VC can automatically fix them:\n\n**How it works:**\n1. Preflight fails â†’ Creates vc-baseline-test issue (P1)\n2. Executor claims baseline issue (vc-208 fix)\n3. Agent receives specialized self-healing prompt\n4. AI diagnoses failure type (flaky/real/environmental)\n5. Agent applies minimal fix with verification\n6. Tests pass â†’ Baseline restored â†’ Work resumes\n\n**Failure Types:**\n- **Flaky**: Race conditions, timing issues â†’ Add sync, remove non-determinism\n- **Real**: Actual bugs â†’ Minimal fix to restore functionality\n- **Environmental**: Missing deps â†’ Mock externals, add setup\n\n**Querying Self-Healing Metrics:**\n\n```sql\n-- Self-healing success rate\nSELECT \n  COUNT(*) as total_attempts,\n  SUM(CASE WHEN json_extract(data, '$.success') = 1 THEN 1 ELSE 0 END) as successful,\n  ROUND(100.0 * SUM(CASE WHEN json_extract(data, '$.success') = 1 THEN 1 ELSE 0 END) / COUNT(*), 2) as success_rate_pct\nFROM agent_events\nWHERE type = 'baseline_test_fix_completed';\n```\n\n**Code:**\n- Prompts: internal/executor/prompt.go:177-237\n- AI Diagnosis: internal/ai/test_failure.go\n- Events: internal/events/types.go (baseline_test_fix_*)\n\nThis keeps the documentation up-to-date with new capabilities.","acceptance_criteria":"- CLAUDE.md includes self-healing section\n- Explains the self-healing workflow\n- Documents failure types and fixes\n- Includes SQL queries for metrics\n- Links to relevant code files\n- Placed logically after preflight section","status":"open","priority":3,"issue_type":"task","created_at":"2025-10-28T17:19:24.798969-07:00","updated_at":"2025-10-28T17:19:24.798969-07:00"}
