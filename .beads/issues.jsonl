{"id":"vc-247","title":"Handle executor restart with stale sandbox metadata","description":"CURRENT: When executor restarts, sandboxes disappear from manager's in-memory active list, but metadata remains in vc_mission_state. GetMissionSandbox() returns error, CreateMissionSandbox() tries to create duplicate.\n\nPROBLEM: CreateMissionSandbox() falls through to create NEW sandbox when metadata exists but sandbox not in manager. This will fail because git branch/worktree already exist.\n\nNEEDED: Explicit handling for executor restart scenario:\n1. Check if git branch exists when metadata present but sandbox not in manager\n2. If branch exists, reconstruct Sandbox object from metadata + git state\n3. Re-add to manager's active list\n4. If branch doesn't exist, clear stale metadata and create fresh\n\nALTERNATIVE: Make manager's sandbox list persistent (DB or filesystem reconstruction on startup)","design":"Options:\n\n**Option 1: Reconstruct on demand**\n- In CreateMissionSandbox(), when metadata exists but sandbox not found\n- Check git branch exists: git show-ref --verify refs/heads/{branch}\n- If exists, create Sandbox object with metadata from DB\n- Add to manager's active list\n- Return reconstructed sandbox\n\n**Option 2: Reconstruct on startup**\n- In NewManager(), scan vc_mission_state for sandbox metadata\n- For each, verify git branch exists\n- Reconstruct Sandbox objects and populate active list\n- Handles all sandboxes at once vs. on-demand\n\n**Option 3: Persistent manager state**\n- Store sandbox list in database table\n- Load on startup, save on create/cleanup\n- Most robust but most complex\n\nRecommend Option 1 (on-demand) for now - simplest and handles the restart case.","acceptance_criteria":"- CreateMissionSandbox() detects stale metadata (metadata exists, sandbox not in manager)\n- Verifies git branch exists using git show-ref\n- If branch exists, reconstructs Sandbox object with correct paths\n- Re-adds sandbox to manager's active list\n- Returns reconstructed sandbox (idempotent)\n- If branch doesn't exist, clears metadata and creates fresh\n- Tests verify behavior after simulated restart\n- Tests verify reconstruction with existing git branch\n- Tests verify cleanup of truly stale metadata","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-29T10:58:39.80308-07:00","updated_at":"2025-10-29T10:58:39.80308-07:00","dependencies":[{"issue_id":"vc-247","depends_on_id":"vc-242","type":"discovered-from","created_at":"2025-10-29T10:59:49.653818-07:00","created_by":"stevey"}]}
{"id":"vc-248","title":"Add database-level locking for concurrent sandbox creation","description":"CURRENT: If two workers call CreateMissionSandbox() simultaneously for the same mission, both might try to create the sandbox, leading to git branch conflicts.\n\nRACE CONDITION:\n1. Worker A: checks metadata (empty), starts creating sandbox\n2. Worker B: checks metadata (still empty), starts creating sandbox\n3. Worker A: creates branch mission/vc-123-auth\n4. Worker B: tries to create same branch → git error\n\nNEEDED: Atomic claim mechanism to prevent concurrent sandbox creation for same mission.\n\nIMPACT: Low - mission creation should be serialized in practice. Git will fail gracefully with 'branch already exists' error. But proper locking would be more robust.","design":"Options:\n\n**Option 1: Database advisory locks (SQLite)**\n- Use BEGIN EXCLUSIVE before sandbox creation\n- Check/update metadata in transaction\n- Prevents concurrent writes to same mission\n\n**Option 2: Row-level locking**\n- SELECT ... FOR UPDATE on vc_mission_state row\n- Create sandbox\n- Update metadata\n- COMMIT\n\n**Option 3: Optimistic locking**\n- Add version column to vc_mission_state\n- Update with WHERE version=old_version\n- Retry if update affects 0 rows\n\n**Option 4: Accept git failure**\n- Keep current behavior\n- Document that git will reject duplicate branch\n- Return existing sandbox on retry\n- Simplest approach\n\nRecommend Option 4 for now (YAGNI), Option 1 if needed later.","acceptance_criteria":"- Choose locking strategy (or accept current behavior)\n- If implementing locks:\n  - CreateMissionSandbox() acquires lock before checking metadata\n  - Lock released after metadata stored\n  - Concurrent calls block until lock released\n  - Tests verify only one sandbox created under concurrency\n  - Tests verify second caller gets existing sandbox\n- If accepting current behavior:\n  - Document race condition and git failure mode\n  - Add retry logic to handle 'branch exists' gracefully","status":"open","priority":3,"issue_type":"task","created_at":"2025-10-29T10:59:01.140869-07:00","updated_at":"2025-10-29T10:59:01.140869-07:00","dependencies":[{"issue_id":"vc-248","depends_on_id":"vc-242","type":"discovered-from","created_at":"2025-10-29T11:00:00.725048-07:00","created_by":"stevey"}]}
{"id":"vc-249","title":"Optimize slugify() regex compilation","description":"CURRENT: slugify() compiles regex on every call:\n\nfunc slugify(s string) string {\n    reg := regexp.MustCompile(`[^a-z0-9]+`)\n    s = reg.ReplaceAllString(s, \"-\")\n    // ...\n}\n\nIMPACT: Minor performance issue. Regex compilation happens once per mission sandbox creation. Not a hot path, but wasteful.\n\nNEEDED: Compile regex once at package initialization.\n\nOPTIMIZATION: Package-level variable with compiled regex.","design":"Simple optimization:\n\nvar slugifyRegex = regexp.MustCompile(`[^a-z0-9]+`)\n\nfunc slugify(s string) string {\n    s = strings.ToLower(s)\n    s = slugifyRegex.ReplaceAllString(s, \"-\")\n    s = strings.Trim(s, \"-\")\n    if len(s) \u003e 50 {\n        s = s[:50]\n        s = strings.TrimRight(s, \"-\")\n    }\n    return s\n}\n\nThis compiles the regex once at package load time instead of on every call.\n\nALTERNATIVE: Use strings.Map() or manual character iteration to avoid regex entirely. Probably overkill for this use case.","acceptance_criteria":"- slugifyRegex is package-level variable\n- Compiled once at package initialization\n- slugify() uses pre-compiled regex\n- All existing slugify tests still pass\n- Benchmark shows improvement (if measurable)","status":"open","priority":3,"issue_type":"task","created_at":"2025-10-29T10:59:17.662366-07:00","updated_at":"2025-10-29T10:59:17.662366-07:00","dependencies":[{"issue_id":"vc-249","depends_on_id":"vc-242","type":"discovered-from","created_at":"2025-10-29T11:00:10.624979-07:00","created_by":"stevey"}]}
{"id":"vc-250","title":"Improve GetMissionSandbox error handling for stale metadata","description":"CURRENT: GetMissionSandbox() returns error when metadata exists but sandbox not in manager:\n\nreturn nil, fmt.Errorf(\"mission %s has sandbox metadata but sandbox not found (may need to recreate)\", missionID)\n\nPROBLEM: This error is confusing because:\n1. Callers don't know HOW to recreate\n2. Unclear if error is transient or permanent\n3. Different from \"no sandbox\" case (returns nil, nil)\n\nINCONSISTENCY: Three possible states should be distinguished:\n- No sandbox: return (nil, nil) ✓\n- Stale metadata: currently returns error ✗\n- Active sandbox: return (sandbox, nil) ✓\n\nNEEDED: Clearer contract for GetMissionSandbox() return values.","design":"Options:\n\n**Option 1: Return (nil, nil) for stale metadata**\n- Treat stale metadata as \"no sandbox\"\n- Log warning about stale metadata\n- Caller can create fresh if needed\n- Simplest for callers\n\n**Option 2: Return error with typed error**\n- Define ErrStaleSandboxMetadata error type\n- Callers can detect and handle specially\n- More explicit but requires error type checking\n\n**Option 3: Auto-reconstruct in GetMissionSandbox**\n- Check if git branch exists\n- Reconstruct Sandbox object if it does\n- Return reconstructed sandbox\n- Same as vc-247 but in Get instead of Create\n\n**Option 4: Return separate boolean flag**\n- GetMissionSandbox() returns (*Sandbox, bool, error)\n- bool indicates if metadata exists but sandbox missing\n- Most explicit but changes API\n\nRecommend Option 1 (return nil, nil) or Option 3 (auto-reconstruct).\nOption 3 pairs well with vc-247.","acceptance_criteria":"- GetMissionSandbox() has clear contract documented\n- Three states handled consistently:\n  - No metadata: return (nil, nil)\n  - Stale metadata: return (nil, nil) OR reconstruct sandbox\n  - Active sandbox: return (sandbox, nil)\n- Error only returned for actual failures (DB error, etc.)\n- Callers can distinguish between 'no sandbox' and 'error'\n- Tests verify all three states\n- Update GetMissionSandbox() docstring with return value contract","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-29T10:59:38.381286-07:00","updated_at":"2025-10-29T10:59:38.381286-07:00","dependencies":[{"issue_id":"vc-250","depends_on_id":"vc-242","type":"discovered-from","created_at":"2025-10-29T11:00:20.867855-07:00","created_by":"stevey"}]}
