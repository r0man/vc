{"id":"vc-206","title":"Fix exclusive lock cleanup when os.Exit() is called","description":"The executor acquires an exclusive lock (.beads/.exclusive-lock) and registers a defer to clean it up. However, if os.Exit() is called anywhere after lock acquisition (e.g., on database freshness check failure, dedup config error, etc.), the defer never runs and the lock file is orphaned.\n\nRoot cause: Go defer statements do not execute when os.Exit() is called.\n\nLines affected in cmd/vc/execute.go:\n- Line 79: os.Exit(1) after freshness check\n- Line 86: os.Exit(1) after dedup config  \n- Line 115: os.Exit(1) after executor creation\n- Line 139: os.Exit(1) after start failure\n\nAll of these bypass the defer at line 67-71.","design":"Replace os.Exit() calls with proper error returns:\n\n1. Refactor executeCmd.Run to use a separate runExecutor() function that returns errors\n2. Have executeCmd.Run call runExecutor() and handle the error/exit at the end\n3. This allows defer statements to run properly before process termination\n\nAlternative: Use atexit-style cleanup with signal handlers, but this is more complex.","acceptance_criteria":"- All os.Exit() calls after lock acquisition are replaced with error returns\n- Lock cleanup defer runs reliably on all error paths\n- Tests verify lock is cleaned up even on early failures\n- No orphaned .beads/.exclusive-lock files after executor errors","notes":"Starting work in Claude Code session - refactoring execute.go to return errors instead of calling os.Exit()","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-10-27T21:07:24.703005-07:00","updated_at":"2025-10-28T11:12:07.669737-07:00","closed_at":"2025-10-28T11:12:07.669737-07:00"}
